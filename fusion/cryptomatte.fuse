--[[
Requires   : Fusion 8
UI         : Kristof Indeherberge  [xmnr0x23@gmail.com]
Code       : Cedric Duriau         [duriau.cedric@live.be]
--]]

-- ===========================================================================
-- modules
-- ===========================================================================
local cryptoutils = require("cryptomatte_utilities")

-- ===========================================================================
-- constants
-- ===========================================================================
FUSE_NAME = "Cryptomatte"
SEPARATOR = string.rep("_", 9999)
SEPARATOR_INDEX = 0
SHOW_CALLBACKS = false

VIEW_MODE_EDGES = "Edges"
VIEW_MODE_COLORS = "Colors"
VIEW_MODE_NONE = "None"
VIEW_MODES = {VIEW_MODE_EDGES, VIEW_MODE_COLORS, VIEW_MODE_NONE}

-- ===========================================================================
-- fuse
-- ===========================================================================
FuRegisterClass(FUSE_NAME, CT_Tool, {
    REGS_Name = FUSE_NAME,
    REGS_Category = FUSE_NAME,
    REGS_OpIconString = FUSE_NAME,
    REGS_OpDescription = FUSE_NAME,
    REG_NoMotionBlurCtrls = true,
    REG_NoBlendCtrls = true,
    REG_OpNoMask = true
})

function Create()
    -- input
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1
    })
    -- output
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1
    })
    
    -- locator & picking
    Locator = self:AddInput("Locator", "Locator", {
        LINKID_DataType = "Point",
        INPID_InputControl = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        ICS_Name = "Matte Locator",
        INP_DoNotifyChanged = true
    })
    BtnAdd = self:AddInput("Add", "Add", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_External = false,
        INP_DoNotifyChanged = true,
        ICD_Width = 0.5
    })
    BtnRemove = self:AddInput("Remove", "Remove", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_External = false,
        INP_DoNotifyChanged = true,
        ICD_Width = 0.5
    })

    create_separator()

    -- view modes
    CbKeyableSurface = self:AddInput("Keyable Surface", "KeyableSurface", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        ICD_Width = 1 / 2,
        INP_DoNotifyChanged = true
    })
    ComboViewMode = self:AddInput("", "ViewMode", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ComboControl",
        INP_Default = 0.0,
        INP_Integer = true,
        ICD_Width = 1 / 2,
        { CCS_AddString = VIEW_MODES[1] },
        { CCS_AddString = VIEW_MODES[2] },
        { CCS_AddString = VIEW_MODES[3] },
        CC_LabelPosition = "Vertical",
        INP_DoNotifyChanged = true
	})
    CbMatteOnly = self:AddInput("Matte Only", "MatteOnly", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        ICD_Width = 1 / 3
    })

    create_separator()

    -- matte list
    TextMatteList = self:AddInput("Matte List", "MatteList", {
        LINKS_Name = "Matte List",
        LINKID_DataType = "Text",
        INPID_InputControl = "TextEditControl",
        TEC_Lines = 1,
        TEC_Wrap = false,
        INP_DoNotifyChanged = false,
        TEC_DeferSetInputs = true
    })
    BtnClear = self:AddInput("Clear", "Clear", {
        LINKS_Name = "Clear",
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_Integer = false,
        ICD_Width = 0.5,
        INP_DoNotifyChanged = true
    })

    create_separator()

    -- layer selection
    SliderCryptoLayer = self:AddInput("Crypto Layer Selection", "CryptoLayerSlider", {
        LINKID_DataType = "Number", 
        INPID_InputControl = "SliderControl", 
        IC_Steps = 1, 
        INP_Integer = true,
        INP_MinAllowed = 1,
        INP_MaxAllowed = 100,
        INP_DoNotifyChanged = true
    })
    TextCryptoLayer = self:AddInput("Crypto Layer", "CryptoLayer", {
        LINKS_Name = "",
        LINKID_DataType = "Text",
        INPID_InputControl = "TextEditControl",
        TEC_Lines = 1,
        TEC_ReadOnly = true,
        INP_DoNotifyChanged = false
    })
    BtnUpdateLoader = self:AddInput("Update Loader", "UpdateLoader", {
        LINKS_Name = "Update Loader",
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_Integer = false,
        ICD_Width = 0.5,
        INP_DoNotifyChanged = true
    })

    -- advanced tab
    -- name checker
    LocatorNameChecker = self:AddInput("Locator Name Checker", "LocatorNameChecker", {
        LINKID_DataType = "Point",
        INPID_InputControl = "OffsetControl",
        INPID_PreviewControl = "CrosshairControl",
        ICS_Name = "Name Checker Locator",
        INP_DoNotifyChanged = true,
        ICS_ControlPage = "Advanced",
        PC_Visible = false
    })
    BtnShow = self:AddInput("Show", "Show", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_External = false,
        INP_DoNotifyChanged = true,
        ICD_Width = 0.5
    })
    BtnHide = self:AddInput("Hide", "Hide", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ButtonControl",
        INP_External = false,
        INP_DoNotifyChanged = true,
        ICD_Width = 0.5
    })
    TextKeyedName = self:AddInput("Keyed Name", "KeyedName", {
        LINKS_Name = "Keyed Name",
        LINKID_DataType = "Text",
        INPID_InputControl = "TextEditControl",
        TEC_Lines = 1,
        TEC_Wrap = false,
        TEC_ReadOnly = true,
        INP_DoNotifyChanged = false
    })

    -- GUI callbacks
    SeparatorCallbacks = create_separator()
    SeparatorCallbacks:SetAttrs({IC_Visible = SHOW_CALLBACKS})
    
    -- callback connect
    CallbackConnect = self:AddInput("Connect Callback", "ConnectCallback", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        IC_Visible = SHOW_CALLBACKS
    })
    -- callback add
    CallbackBtnAdd = self:AddInput("Add Callback", "AddCallback", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        IC_Visible = SHOW_CALLBACKS
    })
    -- callback remove
    CallbackBtnRemove = self:AddInput("Remove Callback", "RemoveCallback", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        IC_Visible = SHOW_CALLBACKS
    })
    -- callback clear
    CallbackBtnClear = self:AddInput("Clear Callback", "ClearCallback", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0.0,
        IC_Visible = SHOW_CALLBACKS
    })
end

-- ===========================================================================
-- utils
-- ===========================================================================
function create_separator()
    SEPARATOR_INDEX = SEPARATOR_INDEX + 1
    return self:AddInput(SEPARATOR, string.format("Separator%s", SEPARATOR_INDEX), {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        INP_External = false,
        INP_Passive = true
    })
end

function create_keyable_image(cryptomatte, cryptomatte00)
    -- shuffle_0
    -- BG: Crypto00
    -- FG: nil
    local shuffle_0 = cryptomatte00:ChannelOpOf("Copy", nil, { R = "bg.R", G = 0.0, B = 0.0, A = "bg.G" })

    -- shuffle_1
    -- BG: Crypto00
    -- FG: nil
    local shuffle_1 = cryptomatte00:ChannelOpOf("Copy", nil, { R = "bg.R", G = "bg.G", B = "bg.B", A = 0.0 })

    -- shuffle_in_keyable
    -- BG: shuffle_0
    -- FG: cryptomatte
    local shuffle_in_keyable = shuffle_0:ChannelOpOf("Copy", cryptomatte, { R = "fg.B", G = "fg.G", B = "bg.R", A = "bg.A" })

    -- shuffle_copy_2
    -- BG: shuffle_1
    -- FG: shuffle_in_keyable
    local shuffle_copy_2 = shuffle_1:ChannelOpOf("Copy", shuffle_in_keyable, { R = "fg.R", G = "fg.G", B = "fg.B", A = "bg.A" })

    -- visual_feedback_shuffle
    -- BG: shuffle_copy_2
    -- FG: nil
    local visual_feedback_shuffle = shuffle_copy_2:ChannelOpOf("Copy", nil, { R = "bg.A", G = "bg.A", B = 0.0, A = 0.0 })

    -- gain_r_g
    -- BG: shuffle_copy_2
    -- FG: nil
    local gain_r_g = shuffle_copy_2:ChannelOpOf("Multiply", nil, { R = 0.25, G = 0.25, B = 1.0, A = 0.0 })

    -- visual_feedback_merge
    -- BG: visual_feedback_shuffle
    -- FG: gain_r_g
    local visual_feedback_merge = visual_feedback_shuffle:ChannelOpOf("Add", gain_r_g, { R = "fg.R", G = "fg.G", B = "fg.B", A = "fg.A" })
    return visual_feedback_merge
end

function get_all_rank_images(input_image)
    --[[
    http://www.steakunderwater.com/VFXPedia/96.0.243.189/index0d66.html?title=Eyeon:Script/Reference/Applications/Fuse/Classes/Image/ChannelOpOf
    case doesn't matter

    --R, G, B, A
        Red, Green, Blue and Alpha channels
    Z
        Z Buffer Channel
    Coverage
        Z buffer coverage channel
    U, V
        U and V co-ordinates channels
    NX, NY, NZ
        XYZ normals channels
    BgR, BgG, BgB, BgA
        The Background Red, Green and Blue channels
    ObjectID, MaterialID
        The ObjectID and MaterialID channels
    VectX, VectY
        The X and Y motion vector channels
    BackVectX, BackVectY
        Background X and Y motion vectors
    HLS.H, HLS.L, HLS.S
        Hue, Lightness and Saturation channels
    YUV.Y, YUV.U, YUV.V
        YUV colorspace channels
    PositionX, PositionY, PositionZ
        world position channels
    DisparityX, DisparityY
    --]]
    local crypto_image_std = input_image:ChannelOpOf("Copy", nil, { R = "bg.R", G = "bg.G", B = "bg.B", A = "bg.A" })
    local crypto_image_00 = input_image:ChannelOpOf("Copy", nil, { R = "bg.Z", G = "bg.Coverage", B = "bg.U", A = "bg.V" })
    local crypto_image_01 = input_image:ChannelOpOf("Copy", nil, { R = "bg.NX", G = "bg.NY", B = "bg.NZ", A = "bg.VectX" })
    local crypto_image_02 = input_image:ChannelOpOf("Copy", nil, { R = "bg.VectY", G = "bg.BackVectX", B = "bg.BackVectY", A = "bg.PositionX" })
    local crypto_image_03 = input_image:ChannelOpOf("Copy", nil, { R = "bg.PositionY", G = "bg.PositionZ", B = "bg.DisparityY", A = "bg.DisparityX" })
    return { crypto_image_std, crypto_image_00, crypto_image_01, crypto_image_02, crypto_image_03}
end

function get_selected_layer()
    -- returns the text inside the crypto layer line edir
    local selected_layer = TextCryptoLayer:GetSource(0).Value
    return selected_layer
end

function get_matte_list_input()
    -- returns the text inside the matte list line edit
    local matte_selection_str = TextMatteList:GetSource(0).Value
    if matte_selection_str == nil then
        return ""
    end
    return matte_selection_str
end

function set_layer_selection_slider(cInfo, default_layer)
    -- sets the correct range of the crypto layer slider and assigns the index of the
    -- default layer as value
    set_slider_attributes(SliderCryptoLayer, 1, cInfo.nr_of_metadata_layers)
    local index = cInfo.layer_name_to_index[default_layer]
    SliderCryptoLayer.SetSource(Number(index), 0, 0)
end

function set_layer_selection_display(cInfo)
    -- sets the text inside the crypto layer line edit based on the current index
    -- of the crypto layer slider
    local slider_index = SliderCryptoLayer:GetSource(0).Value
    local layer_name = cInfo.index_to_layer_name[slider_index]
    local current_layer = get_selected_layer()
    if current_layer ~= layer_name then
        TextCryptoLayer:SetSource(Text(layer_name), 0, 0)
    end
end

function set_slider_attributes(slider, min, max)
    -- sets the attributes of the given slider with given min and max to be able to
    -- dynamically change the slider's range correctly
    slider:SetAttrs({ INP_MinAllowed = min, 
                      INP_MaxAllowed = max,
                      INP_MinScale = min, 
                      INP_MaxScale = max})
end

function get_screen_pixel(img, x, y)
    -- get the pixel at given location of given image
    local p = Pixel()
    local pixel_x = math.floor(img.Width / (1 / x))
    local pixel_y = math.floor(img.Height / (1 / y))
    img:GetPixel(pixel_x, pixel_y, p)
    return p
end

function convert_str_to_array(str, pattern)
    -- convert matte selection list in str format to set
    local matte_names = {}
    for matte in string.gmatch(str, pattern) do
        -- strip the leading and trailing double quote
        matte = string.sub(matte, 2, matte:len() - 1)
        table.insert(matte_names, matte)
    end
    return matte_names
end

function get_mattes_from_selection(cInfo, matte_selection_str)
    -- cross matches the mattes given in the matte list line edit and the manifest mattes
    local mattes = {}
    local manifest_matte_names = cInfo.cryptomattes[cInfo.selection]["names"]

    -- convert the matte input string to an array
    local matte_name_array = convert_str_to_array(matte_selection_str, MATTE_LIST_REGEX)

    -- cross match matte names and store matches inside a set
    for _, matte in ipairs(matte_name_array) do
        if manifest_matte_names[matte] then
            mattes[matte] = true
        end
    end
    return mattes
end

function update_matte_list(cInfo, matte_name, remove, matte_selection_str)
    -- updates the matte list line edit text with given data

    -- get valid matte names cross matches from manifest
    local matte_set = get_mattes_from_selection(cInfo, matte_selection_str)
    
    -- check if the matte to add/remove is present in the set
    local matte_present = matte_set[matte_name]

    if remove then
        -- remove matte from set
        if matte_present then
            matte_set[matte_name] = nil
        end
    else
        -- add matte to set
        if not matte_present then
            matte_set[matte_name] = true
        end
    end

    -- wrap matte names inside set with double string quotes
    local new_content = {}
    for matte_name, _ in pairs(matte_set) do
        matte_name = "\"" .. matte_name .. "\""
        table.insert(new_content, matte_name)
    end
    
    -- concatenate the set into a string
    -- string concat .. operator allocates more memory than table.concat
    local new_content_str = table.concat(new_content, ", ")
    return new_content_str
end

function set_matte_list(matte_list_str)
    -- sets the given matte list string into the matte list line edit
    TextMatteList:SetSource(Text(matte_list_str), 0, 0)
end

function add_matte(cInfo, id_float_value, matte_selection_str)
    local matte_name = cInfo.cryptomattes[cInfo.selection]["id_to_name"][id_float_value]
    if not matte_name then return end
    local new_matte_list = update_matte_list(cInfo, matte_name, false, matte_selection_str)
    set_matte_list(new_matte_list)
end

function remove_matte(cInfo, id_float_value, matte_selection_str)
    local matte_name = cInfo.cryptomattes[cInfo.selection]["id_to_name"][id_float_value]
    if not matte_name then return end
    local new_matte_list = update_matte_list(cInfo, matte_name, true, matte_selection_str)
    set_matte_list(new_matte_list)
end

function set_name_checker(output_image)
    -- get screen pixel at locator position
    local screen_pos = LocatorNameChecker:GetSource(0)
    local pixel = get_screen_pixel(output_image, screen_pos.X, screen_pos.Y)

    -- get matte name matching id float value
    local id_float_value = pixel.B
    local text_to_set = ""
    if id_float_value == 0.0 then
        text_to_set = "Background (Value is 0.0)"
    else
        text_to_set = cInfo.cryptomattes[cInfo.selection]["id_to_name"][id_float_value]
        if not text_to_set then
            return
        end
        text_to_set = "\"" .. text_to_set .. "\""
    end
    
    -- set the keyed name if different then before
    local keyed_name = TextKeyedName:GetSource(0).Value
    if text_to_set ~= keyed_name then
        TextKeyedName:SetSource(Text(text_to_set), 0, 0)
    end
end

function get_view_mode()
    -- returns the selected view mode if the keyable surface is checked
    -- else return default view mode "None"
    local view_mode = VIEW_MODES[3]
    local keyable_checked = CbKeyableSurface:GetSource(0).Value
    if keyable_checked == 1  then
        local selected_view_mode_index = ComboViewMode:GetSource(0).Value
        view_mode = VIEW_MODES[selected_view_mode_index + 1]
    end
    return view_mode
end

function apply_view_mode(mode, input_image, keyable_image, matte)
    local output_image = Image({})
    output_image:Clear()
    if mode == VIEW_MODE_EDGES then
        output_image = input_image:ChannelOpOf("Add", matte, { R = "fg.V", G = "fg.V"})
    elseif mode == VIEW_MODE_COLORS then
        output_image = keyable_image:ChannelOpOf("Add", matte, { R = "fg.A", G = "fg.A", B = "fg.A"})
    elseif mode == VIEW_MODE_NONE then
        output_image = input_image:ChannelOpOf("Add", matte, { R = "fg.A", G = "fg.A", B = "fg.A"})
    end
    return output_image
end

-- ===========================================================================
-- main
-- ===========================================================================
function OnConnected(inp, old, new)
    if inp == InImage and new ~= nil then
        CallbackConnect:SetSource(Number(1), 0, 0)
    end
end

function Process(req)
    local t_start = os.clock()

    -- get input image
    local input_image = InImage:GetValue(req)
    local metadata = input_image.Metadata
    
    -- get current selected layer
    local layer_name = get_selected_layer()

    -- create cryptomatte information object
    local cInfo = cryptoutils:create_cryptomatte_info(metadata, layer_name)

    -- refresh the manifest
    cInfo:parse_manifest()
    
    -- populate layer selection
    set_layer_selection_slider(cInfo)
    set_layer_selection_display(cInfo)

    -- get loader connected to fuse
     local connect_triggered = CallbackConnect:GetValue(req).Value
    if connect_triggered == 1 then
        local fusion = Fusion()
        local comp = fusion.CurrentComp
        if comp then
            local tool = comp:FindTool(self.Name)
            local loader = cryptoutils:get_input_loader(tool)
            -- get all channels listed in the loader's first channel slot
            local all_channels = cryptoutils:get_all_channels_from_loader(cInfo, loader)
            -- get all unique ranks from the channel list
            local ranks = cryptoutils:get_all_ranks_from_channels(all_channels)
            -- fill in all the remaining slots correctly
            cryptoutils:set_channel_slots(loader, ranks)
            -- reset callback
            CallbackConnect:SetSource(Number(0), 0, 0)
        end
    end
    
    -- create keyable image & matte only mono channel image
    local crypto_images = get_all_rank_images(input_image)
    local keyable_image = create_keyable_image(crypto_images[1], crypto_images[2])
    
    -- set the name checker
    set_name_checker(keyable_image)

    -- add mattes callback
    -- remove mattes callback
    local add_triggered = CallbackBtnAdd:GetValue(req).Value
    local remove_triggered = CallbackBtnRemove:GetValue(req).Value
    local matte_selection_str = get_matte_list_input()
    if add_triggered == 1 or remove_triggered == 1 then
        -- get the id float value (blue channel of the pixel on matte locator position)
        local position = Locator:GetSource(0)
        local pixel = get_screen_pixel(keyable_image, position.X, position.Y)
        local id_float_value = pixel.B

        if add_triggered == 1 then
            add_matte(cInfo, id_float_value, matte_selection_str)
            -- reset the callback
            CallbackBtnAdd:SetSource(Number(0), 0, 0)
        end
        if remove_triggered == 1 then
            remove_matte(cInfo, id_float_value, matte_selection_str)
            -- reset the callback
            CallbackBtnRemove:SetSource(Number(0), 0, 0)
        end
    end
    -- clear matte callback
    local clear_triggered = CallbackBtnClear:GetValue(req).Value
    if clear_triggered == 1 then
        -- clear the other ui elements
        TextMatteList:SetSource(Text(""), 0, 0)
        CbMatteOnly:SetSource(Number(0), 0, 0)
        -- reset the callback
        CallbackBtnClear:SetSource(Number(0), 0, 0)
    end

    -- rebuild matte
    local matte_names = get_mattes_from_selection(cInfo, matte_selection_str)
    local matte = cryptoutils:rebuild_matte(cInfo, matte_names, crypto_images)

    -- apply matte to image depending on view mode
    local view_mode = get_view_mode()
    local output_image = apply_view_mode(view_mode, input_image, keyable_image, matte)

    -- set the matte as the alpha of the output image
    output_image = output_image:ChannelOpOf("Copy", matte, { A = "fg.A" })

    -- show final matte or standard visual feedback
    local matte_only = CbMatteOnly:GetValue(req).Value
    if matte_only == 1 then
        -- create mono channel alpha image from output image
        local matte_only_image = Image({ IMG_Like = output_image, IMG_CopyChannels = false, { IMG_Channel = "Alpha" } })
        matte_only_image = matte_only_image:ChannelOpOf("Copy", output_image, { A = "fg.A" })
        OutImage:Set(req, matte_only_image)
    else
        OutImage:Set(req, output_image)
    end
    print(string.format("est %.6f", os.clock() - t_start))
end

function NotifyChanged(inp, param, time)
    -- trigger callbacks
    if param and param.Value == 1 then
        if inp == BtnAdd then 
            CallbackBtnAdd:SetSource(Number(1), 0, 0)
        elseif inp == BtnRemove then
            CallbackBtnRemove:SetSource(Number(1), 0, 0)
        elseif inp == BtnClear then
            CallbackBtnClear:SetSource(Number(1), 0, 0)
        elseif inp == BtnShow then
            LocatorNameChecker:SetAttrs({ PC_Visible = true })
        elseif inp == BtnHide then
            LocatorNameChecker:SetAttrs({ PC_Visible = false })
        elseif inp == BtnUpdateLoader then
            CallbackConnect:SetSource(Number(1), 0, 0)
        end
    end
end
