{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe2052{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue0;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sl276\slmult1\cf1\b\f0\fs36 Cryptomatte Specification version 0.2.0\b0\fs22\par
\b\fs24\par
\fs22 Version 0.1.0\par
\par
\b0 This version of the specification is just a formal writeup of what the Psyop tool is doing currently. It is only meant as a starting point for the committee. \par
\pard\sl276\slmult1\b\fs24\par
\pard\sl276\slmult1\fs22 Version 0.2.0\par
\par
\b0 Changes the hash to MurmurHash3. \b\par
\par
Table of Contents:\par
\fs24\par
\pard\fi-360\li720\sl276\slmult1\tx360\b0 1.\tab EXR File\par
\pard\fi-360\li1440\sl276\slmult1\tx1080 a.\tab Overview\par
b.\tab Channel Naming\par
c.\tab Channel Contents\par
d.\tab Manifest\par
\pard\fi-360\li720\sl276\slmult1\tx360 2.\tab ID Generation\par
\pard\fi-360\li1440\sl276\slmult1\tx1080 a.\tab Overview\par
b.\tab Names\par
c.\tab Hash\par
d.\tab Example code\par
\pard\fi-360\li720\sl276\slmult1\tx360 3.\tab Ranking Pixel Filter\par
\pard\fi-360\li1440\sl276\slmult1\tx1080 a.\tab Overview\par
\pard\sl276\slmult1\par
\par
\par
\b\fs36 EXR File:\par
\b0\fs22\par
\b Overview\par
\par
\b0 The format consists of RGBA images in a multichannel EXR, which use a naming convention to allow detection as a series of channels cryptomatte can use. EXR header metadata is used to store a manifest. \par
\par
\b Channel naming\par
\b0\par
An example:\par
\par
\pard\li720\sl276\slmult1\f1\fs18 CryptoObject\par
CryptoObject00\par
CryptoObject01\par
\'85\par
\pard\sl276\slmult1\f0\fs22\par
Or more formally, there is no requirement to use the word \ldblquote Crypto\rdblquote  in the name. \par
\f1\par
\pard\li720\sl276\slmult1\fs18\{typename\}\par
\{typename\}00\par
\{typename\}01\par
\{typename\}02\par
\'85\par
\pard\sl276\slmult1\f0\fs22\par
\b Channel contents\par
\par
\b0 An arbitrary number of numbered channels in this format are allowed. The number of channels used should be the same for all frames of the image sequence rendered. Otherwise it may be set automatically, manually, or to a given value based on any criteria the implementer desires. The suggested default value is 6 levels, meaning 3 numbered EXR layers (00, 01, and 02). \par
\b\par
\b0 The contents of these layers are:\par
\par
\pard\li720\sl276\slmult1\f1\fs18\{typename\}.r   - Ordinarily filtered color generated from IDs\par
\{typename\}.g   - Ordinarily filtered color generated from IDs\par
\{typename\}.b   - Unused (black)\par
\{typename\}.a   - Unused (black)\par
\par
\{typename\}00.r - ID rank 0\par
\{typename\}00.g - Coverage for ID rank 0\par
\{typename\}00.b - ID rank 1\par
\{typename\}00.a - Coverage for ID rank 1\par
\par
\{typename\}01.r - ID rank 2\par
\{typename\}01.g - Coverage for ID rank 2\par
\{typename\}01.b - ID rank 3\par
\{typename\}01.a - Coverage for ID rank 3\par
\par
\{typename\}02.r - ID rank 4\par
\{typename\}02.g - Coverage for ID rank 4\par
\{typename\}02.b - ID rank 5\par
\{typename\}02.a - Coverage for ID rank 5\par
\pard\sl276\slmult1\fs22\par
\b\f0 Manifest\par
\b0\par
The file should (but is not required to) contain a manifest in the EXR header. The manifest encodes a list of alternating hashes and names. The metadata entry name is \ldblquote cryptoManifest\rdblquote .\par
\par
\pard\li720\sl276\slmult1\fs18 exr/cryptoManifest = \f1 <hash>0.5634760857<name>bunny<hash>4.446198463<name>default<hash>1.600968361<name>flowerA<hash>3.584468842<name>flowerB<hash>2.320055485<name>heroflower<hash>5.530207157<name>plant<hash>7.99622488<name>set\f0\par
\pard\sl276\slmult1\fs22\par
The hash values are encoded in decimal, to enough precision that all floating points can be unambiguously represented (10 places). \par
\par
\pard\li720\sl276\slmult1\f1\fs18 char hash_float_char[20];\par
memset(hash_float_char, 0, sizeof(hash_float_char));\par
sprintf(hash_float_char, "%.10g", hash_value);\par
\pard\sl276\slmult1\f0\fs22\par
Including the manifest is optional but very good for user experience when decoding. Decoders should not rely on it to accurately extract mattes. The only characters not allowed in the manifest are angle brackets, \ldblquote <\rdblquote  and \ldblquote >\rdblquote . \par
\par
\par
\par
\b\fs36 ID Generation\par
\b0\fs22\par
\b Overview\par
\b0\par
IDs are generated from string values inside the renderer. In our implementation, we use names, but any string values may be used.\par
\par
\b Names\par
\b0\par
Any per-object string values may be used to compute IDs. Where these string values overlap, the IDs will be combined (an expected and desired behavior). \par
\par
It\rquote s suggested that in most implementations, the most useful groupings will come from namespace, object name (sans namespace), and material name (also sans namespace), but arbitrary data can be used. \par
\par
Each set of names should be written to the manifest. If this is not possible (due to deferred loading), matte extraction will still work but users will not have access to the names. \par
\par
\b Hash\par
\par
\b0 We use the standard 32 bit variant of MurmurHash3 as our hashing algorithm. \par
\par
Our implementation generates IDs while ray tracing. This is an implementation specific decision to handle edge cases such as delayed load render archives. Precaching the hash values per object is also fine. \par
\par
If there is no object in the sample,  the recorded hash value should be zero. \par
\par
\b Floating point conversion\par
\b0\par
We store our IDs as 32 bit floating point values. While not ideal, this is necessary for a variety of software specific reasons reasons and works fine in practice. \par
\par
We use as many 32-bit floating point values as possible to help minimize hash collisions.  Unfortunately, all 32 bits cannot be used, due to NaN and inf signal values potentially being indistinguishable from each other in certain contexts, and being problematic for computation in general.\par
\par
Our conversion of the 32 bit integer hash to a 32 bit float is effectively a reinterpret_cast, with logic to clamp the exponent to acceptable values. The exponent is modified, clamped to be within the [1:254] range. \par
\par
\b Example code\par
\par
\b0 This example code shows conversion of hashes to float. The hash used is standard MurmurHash3 and is not shown here. The C++ example also shows a method for creating two additional channels of data for the normally filtered \ldblquote keyable\rdblquote  image. \par
\par
Python:\par
\pard\li720\sl276\slmult1\f1\fs18 def mm3hash_float(name):\par
    import pymmh3\par
    hash_32 = pymmh3.hash(name)\par
\par
    mantissa = hash_32 & ((1 << 23) - 1)\par
    exp = (hash_32 >> 23) & ((1 << 8) - 1)\par
    exp = max(exp, 1)\par
    exp = min(exp, 254)\par
    exp =  exp << 23\par
    sign = (hash_32 >> 31);\par
    float_bits = exp | mantissa\par
    packed = struct.pack('@l', float_bits)\par
    if sign == 1:\par
        return -struct.unpack('@f', packed)[0]\par
    elif sign == 0:\par
        return struct.unpack('@f', packed)[0]\par
\par
\pard\sl276\slmult1\f0\fs22 C++: \par
\pard\li720\sl276\slmult1\f1\fs16 float hash_to_float(uint32_t hash) \{\par
    uint32_t mantissa = hash & (( 1 << 23) - 1);\par
    uint32_t exponent = (hash >> 23) & ((1 << 8) - 1);\par
    exponent = std::max(exponent, (uint32_t) 1);\par
    exponent = std::min(exponent, (uint32_t) 254);\par
    exponent = exponent << 23;\par
    uint32_t sign = (hash >> 31);\par
    sign = sign << 31;\par
    uint32_t float_bits = sign | exponent | mantissa;\par
    return *reinterpret_cast<float*>(&float_bits);\par
\}\par
\par
void hash_name_rgb(char * name, AtColor* out_color) \{\par
    // This puts the float ID into the red channel, and the human-readable\par
    // versions into the G and B channels. \par
    uint32_t m3hash = 0;\par
    MurmurHash3_x86_32(name, strlen(name), 0, &m3hash);\par
    out_color->r = hash_to_float(m3hash);\par
    out_color->g = ((float) ((m3hash << 8)) /  (float) UINT32_MAX);\par
    out_color->b = ((float) ((m3hash << 16)) / (float) UINT32_MAX);\par
\}\par
\pard\sl276\slmult1\f0\fs22\par
\par
\par
\b\fs36 Ranking Pixel Filter\par
\b0\fs22\par
\b Overview \par
\par
\b0 IDs are stored as AOVs. The pixel filter uses a filter kernel that ideally matches the kernel used to filter the associated \ldblquote beauty\rdblquote  renders. The samples are weighted by the kernel, and the weights of each unique ID that contributes to the pixel are summed. Non-refractive transparency is taken into account here as well, in whatever way matches the way the renderer computes opacity. The weights are normalized by dividing by the total weight of samples contributing to the pixel, and the weights become coverage values. \par
\par
Each unique ID found contributing to the pixel is ranked by its accumulated weight, and the highest ranked ID is ID 0, the next is ID 1, and these IDs and associated coverage values are encoded into the EXR channels described above. \par
}
 